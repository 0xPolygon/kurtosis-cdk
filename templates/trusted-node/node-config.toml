# ==============================================================================
#  ____   ___  _  __   ______  ___  _   _
# |  _ \ / _ \| | \ \ / / ___|/ _ \| \ | |
# | |_) | | | | |  \ V / |  _| | | |  \| |
# |  __/| |_| | |___| || |_| | |_| | |\  |
# |_|    \___/|_____|_| \____|\___/|_| \_|
#   ____ ____  _  __
#  / ___|  _ \| |/ /
# | |   | | | | ' /
# | |___| |_| | . \
#  \____|____/|_|\_\
#
# This is a reference config file used by the Kurtosis CDK Testing
# setup. The values here should work, but are necessarily meant for
# production environments. DYOR
# ------------------------------------------------------------------------------


# ------------------------------------------------------------------------------
# IsTrustedSequencer is used to configure if the node has as a trusted
# node or not. This setting has implications beyond the sequencer. In
# the case of a validium, setting IsTrustedSequencer to true for a
# permissionless node forces the synchronizer to pull data from the
# DAC because it assumes that it cannot pull from a trusted sequencer.
# ------------------------------------------------------------------------------
IsTrustedSequencer = true

# ------------------------------------------------------------------------------
# ForkUpgradeBatchNumber is used to configure a batch number that will
# use a new fork id. The idea is that we could continue sequencing
# transactions but stop virtualizing. In many cases, if you're okay
# with some downtime for an upgrade it's much simpler to just stop all
# of the components.
#
# https://github.com/0xPolygonHermez/zkevm-node/issues/2236
#
# ------------------------------------------------------------------------------
ForkUpgradeBatchNumber = 0

# ------------------------------------------------------------------------------
# ForkUpgradeNewForkId is used to specify the new fork id that we'll
# be upgrading to.
# ------------------------------------------------------------------------------
ForkUpgradeNewForkId = 0

# ==============================================================================
#  _     ___   ____
# | |   / _ \ / ___|
# | |  | | | | |  _
# | |__| |_| | |_| |
# |_____\___/ \____|
#
# ------------------------------------------------------------------------------
[Log]

# ------------------------------------------------------------------------------
# Environment generally dictates the format of the logs and the
# sampling rate. We often default to production even for development
# because of the JSON encoding.
#
# https://github.com/uber-go/zap/blob/a55bdc32f526699c3b4cc51a2cc97e944d02fbbf/config.go#L120
# https://github.com/uber-go/zap/blob/a55bdc32f526699c3b4cc51a2cc97e944d02fbbf/config.go#L161
# ------------------------------------------------------------------------------
Environment = "production"

# ------------------------------------------------------------------------------
# Level determines the log level that will be written to the
# log. Generally we'll switch to debug if we want to troubleshoot
# something specifically otherwise we leave it at info
# ------------------------------------------------------------------------------
Level = "info"

# ------------------------------------------------------------------------------
# Outputs define the output paths for writing logs. The default is to
# write to stderr, but other output paths should be supported
#
# https://github.com/uber-go/zap/blob/a55bdc32f526699c3b4cc51a2cc97e944d02fbbf/writer.go#L32-L50
# ------------------------------------------------------------------------------
Outputs = ["stderr"]

# ==============================================================================
#  _____ _____ _   _ _____ ____  __  __    _    _   _
# | ____|_   _| | | | ____|  _ \|  \/  |  / \  | \ | |
# |  _|   | | | |_| |  _| | |_) | |\/| | / _ \ |  \| |
# | |___  | | |  _  | |___|  _ <| |  | |/ ___ \| |\  |
# |_____| |_| |_| |_|_____|_| \_\_|  |_/_/   \_\_| \_|
#
# ------------------------------------------------------------------------------
[Etherman]

# ------------------------------------------------------------------------------
# URL should be used to configure your L1 RPC address.
# ------------------------------------------------------------------------------
URL = "{{.l1_rpc_url}}"

# ------------------------------------------------------------------------------
# ForkIDChunkSize is used to configure how big a rang of blocks can be
# searched while initializing the chain. Some RPC providers will limit
# you to 10000 blocks at a time
# ------------------------------------------------------------------------------
ForkIDChunkSize = 9999

# ------------------------------------------------------------------------------
# MultiGasProvider can be set to true in order to use a gas station
# provider in addition to using a normal RPC gas pricer. This feature
# is not used as far as we know
#
# Deprecated: This feature currently uses gas station which has been
# decommissioned
#
# ------------------------------------------------------------------------------
MultiGasProvider = false

[Etherman.Etherscan]

# ------------------------------------------------------------------------------
# ApiKey is key for using the gas station service
#
# Deprecated: This feature currently uses gas station which has been
# decommissioned
#
# ------------------------------------------------------------------------------
ApiKey = ""

# ------------------------------------------------------------------------------
# Url is a custom URL for a gas station
#
# Deprecated: This feature currently uses gas station which has been
# decommissioned
#
# ------------------------------------------------------------------------------
Url = ""

# ==============================================================================
#  _____ _____ _   _ _______  ____  __    _    _   _    _    ____ _____ ____
# | ____|_   _| | | |_   _\ \/ /  \/  |  / \  | \ | |  / \  / ___| ____|  _ \
# |  _|   | | | |_| | | |  \  /| |\/| | / _ \ |  \| | / _ \| |  _|  _| | |_) |
# | |___  | | |  _  | | |  /  \| |  | |/ ___ \| |\  |/ ___ \ |_| | |___|  _ <
# |_____| |_| |_| |_| |_| /_/\_\_|  |_/_/   \_\_| \_/_/   \_\____|_____|_| \_\
#
# ------------------------------------------------------------------------------
[EthTxManager]

# ------------------------------------------------------------------------------
# FrequencyToMonitorTxs determines how often we'll process pending
# monitored transactions. Essentially we'll query the database looking
# for created, sent, and reorged transactions. For each one of those
# txs, we'll try to send it or confirm if it has been sent and update
# the status accordingly.
#
# Setting this duration can potentially create a lot of logs
# especially if there is nothing to do.
# ------------------------------------------------------------------------------
FrequencyToMonitorTxs = "5s"

# ------------------------------------------------------------------------------
# WaitTxToBeMined will determine how long we'll wait for a transaction
# to be mined after it's been published. If this interval is too
# short, you're more likely to run into oddities where the nonce is
# reused.
#
# The code for sending transactions does not create a goroutine. It
# will block for the duration of the wait.
# ------------------------------------------------------------------------------
WaitTxToBeMined = "4m0s"

# ------------------------------------------------------------------------------
# ForcedGas can be used to configure a default gas limit to use in the
# case of a gas estimation error. If this is configured as 0, the
# default behavior would be to return the gas estimation error and
# retry later.
# ------------------------------------------------------------------------------
ForcedGas = 0

# ------------------------------------------------------------------------------
# GasPriceMarginFactor is used to bias the gas price by whatever the
# configured factor is. If we want to make sure our transactions are
# mined quickly especially if there is volatility, we could set this
# factor to be 1.2 in order to make sure that our transactions are
# attractive.
#
# Generally, we would not recommend setting this below 1. If you're
# looking to save on gas costs, there are better ways.
# ------------------------------------------------------------------------------
GasPriceMarginFactor = 1.25

# ------------------------------------------------------------------------------
# MaxGasPriceLimit is used to specify in wei the upper limit price
# that we would be willing to pay. If the current gas price exceeds
# this limit, we'll adjust the gas price down to the configured limit
# and try to send the transaction. If the limit is below the base fee,
# the transaction probably would not be accepted by the RPC.
# ------------------------------------------------------------------------------
MaxGasPriceLimit = 0

# ------------------------------------------------------------------------------
# PrivateKeys is an array of keystores and passwords that are used for
# signing transactions. The keystores are standard go-ethereum style
# keystores that are encrypted with the provided password. Depending
# on your deployment setup, you'll need to configure the sequencer
# and/org aggregator key so that the tx manager for the given
# component can sign and send transactions.
#
# ------------------------------------------------------------------------------
[[EthTxManager.PrivateKeys]]
Path = "/etc/zkevm/sequencer.keystore"
Password = "{{.zkevm_l2_keystore_password}}"

[[EthTxManager.PrivateKeys]]
Path = "/etc/zkevm/aggregator.keystore"
Password = "{{.zkevm_l2_keystore_password}}"

# ==============================================================================
#  ____   ___   ___  _
# |  _ \ / _ \ / _ \| |
# | |_) | | | | | | | |
# |  __/| |_| | |_| | |___
# |_|    \___/ \___/|_____|
#
# ------------------------------------------------------------------------------
[Pool]

# ------------------------------------------------------------------------------
# IntervalToRefreshBlockedAddresses determines how often we'll query
# the database in order to update the list of blocked addresses. If
# you're frequently blocking and unblocking addresses, it might make
# sense to increase the frequency.
# ------------------------------------------------------------------------------
IntervalToRefreshBlockedAddresses = "5m"

# ------------------------------------------------------------------------------
# IntervalToRefreshGasPrices determines how often we'll query the
# database for updated L1 and L2 gas prices. This number should
# probably be in line with the configured frequency for the
# L2GaspriceSuggester's update period
# ------------------------------------------------------------------------------
IntervalToRefreshGasPrices = "10s"

# ------------------------------------------------------------------------------
# MaxTxBytesSize configures the RPC limit for the max size of a
# transaction. In addition to the data, there are other fields like
# access lists that have potential to take up a lot of space.
# ------------------------------------------------------------------------------
MaxTxBytesSize = 100132

# ------------------------------------------------------------------------------
# MaxTxDataBytesSize configured how big a transaction's input / data
# field can be. This will have implications for contract deployments
# and calls.
# ------------------------------------------------------------------------------
MaxTxDataBytesSize = 100000

# ------------------------------------------------------------------------------
# DefaultMinGasPriceAllowed is used to configure a minimum allowable
# gas price in L2. When initially bootstrapping a network and
# performing the initial bridge, you'll often need to set these to be
# 0 in order to do some initial zero priced transactions.
# ------------------------------------------------------------------------------
DefaultMinGasPriceAllowed = 1000000000

# ------------------------------------------------------------------------------
# MinAllowedGasPriceInterval determines how far we'll look back when
# determining the gas price. We track gas prices over time. If the L1
# gas prices are climbing rapidly, we'll be less profitable if this
# interval is very long. If we want to be more reactive to the L1 gas
# price, this can be configured for a shorter duration.
# ------------------------------------------------------------------------------
MinAllowedGasPriceInterval = "5m"

# ------------------------------------------------------------------------------
# PollMinAllowedGasPriceInterval works in tandem with
# MinAllowedGasPriceInterval. Every period of
# PollMinAllowedGasPriceInterval we'll query our database looking back
# for a period of MinAllowedGasPriceInterval to find the min gas
# price. We'll then update the current suggested gas price in our pool
# with that value.
# ------------------------------------------------------------------------------
PollMinAllowedGasPriceInterval = "15s"

# ------------------------------------------------------------------------------
# AccountQueue determines how many non-executable transactions can be
# in the pool from a single address. If this value is configured to be
# too high relative to the size of the GlobalQueue, it becomes
# possible that a few users can fill up the entire pool. It's
# advisable to keep this particular number lower in order to avoid a
# single account filling up the entire pool and creating a DoS
# ------------------------------------------------------------------------------
AccountQueue = 64

# ------------------------------------------------------------------------------
# GlobalQueue determines how many total non-executable transactions
# can be in the pool across all account. Depending on overall
# resources and throughput requirement this number may need to be
# adjusted. It can be configured to be 0 in order to make the pool
# unlimited.
# ------------------------------------------------------------------------------
GlobalQueue = 1024

# ------------------------------------------------------------------------------
# ForkID is the current fork ID of the chain.
#
# Deprecated: In most cases the fork id is read from the chain and
# does not need to be configured like this.
# ------------------------------------------------------------------------------
ForkID = 0

[Pool.DB]
# ------------------------------------------------------------------------------
# User specifies the username for database connection authentication.
# ------------------------------------------------------------------------------
User = "{{.pool_db.user}}"

# ------------------------------------------------------------------------------
# Password is the authentication credential for the database connection.
# ------------------------------------------------------------------------------
Password = "{{.pool_db.password}}"

# ------------------------------------------------------------------------------
# Name is the identifier of the target database to connect to.
# ------------------------------------------------------------------------------
Name = "{{.pool_db.name}}"

# ------------------------------------------------------------------------------
# Host is the network address (hostname or IP) used to establish a database
# connection. Append deployment-specific suffixes as needed.
# ------------------------------------------------------------------------------
Host = "{{.pool_db.hostname}}"

# ------------------------------------------------------------------------------
# Port defines the network port used for the database connection.
# ------------------------------------------------------------------------------
Port = "{{.pool_db.port}}"

# ------------------------------------------------------------------------------
# EnableLog toggles the logging of all executed queries. Enabling this
# feature will significantly increase log volume and may affect performance.
# ------------------------------------------------------------------------------
EnableLog = false

# ------------------------------------------------------------------------------
# MaxConns sets the maximum number of concurrent connections in the pool.
# Adjust this value based on the database's configuration limits and expected
# client load to optimize performance and resource utilization.
# ------------------------------------------------------------------------------
MaxConns = 20

[Pool.EffectiveGasPrice]

# ------------------------------------------------------------------------------
# Enabled will determine if we use the effective gas price logic. The
# details of this feature are a bit complicated but at a high level it
# allows for additional gas savings to be passed on the user.
#
# https://github.com/0xPolygonHermez/zkevm-rom/issues/316
# https://polygon.technology/blog/polygon-zkevm-effective-gas-price-live-on-mainnet-beta
# ------------------------------------------------------------------------------
Enabled = true

# ------------------------------------------------------------------------------
# L1GasPriceFactor is used to determine the ratio of L1 to L2 gas
# prices.
# ------------------------------------------------------------------------------
L1GasPriceFactor = 0.008

# ------------------------------------------------------------------------------
# ByteGasCost is used in the effective gas price calculations and
# determines how much we should charge per non-zero byte of data
# availability
# ------------------------------------------------------------------------------
ByteGasCost = 20

# ------------------------------------------------------------------------------
# ZeroByteGasCost is used in the effective gas price calculations to
# determine how much we should charge per zero byte of data
# availability
# ------------------------------------------------------------------------------
ZeroByteGasCost = 5

# ------------------------------------------------------------------------------
# NetProfit is used in the calculation of the break even gas
# price. This factor determines how we determine our break even point.
# ------------------------------------------------------------------------------
NetProfit = 1

# ------------------------------------------------------------------------------
# BreakEvenFactor is used after the break even gas price has been
# determined. It is used to in the comparison of the signed gas price
# to determine if we should use the signed gas price or the effective
# gas price.
# ------------------------------------------------------------------------------
BreakEvenFactor = 1.3

# ------------------------------------------------------------------------------
# FinalDeviationPct is the maxed allowed difference between the break
# even gas price upon successive re-calculations
# ------------------------------------------------------------------------------
FinalDeviationPct = 10

# ------------------------------------------------------------------------------
# EthTransferGasPrice is the fixed gas price returned as effective gas
# price for txs that are ETH transfers (0 means disabled) Only one of
# EthTransferGasPrice or EthTransferL1GasPriceFactor params can be
# different than 0. If both params are set to 0, the sequencer will
# halt and log an error
# ------------------------------------------------------------------------------
EthTransferGasPrice = 0

# ------------------------------------------------------------------------------
# EthTransferL1GasPriceFactor is the percentage of L1 gas price
# returned as effective gas price for txs that are ETH transfers (0
# means disabled) Only one of EthTransferGasPrice or
# EthTransferL1GasPriceFactor params can be different than 0. If both
# params are set to 0, the sequencer will halt and log an error
# ------------------------------------------------------------------------------
EthTransferL1GasPriceFactor = 0

# ------------------------------------------------------------------------------
# L2GasPriceSuggesterFactor is used if the the EffectiveGasPrice
# component is not enabled but is still somehow being called to
# provide a gas price. This is likely only used in testing or
# debugging purposes.
# ------------------------------------------------------------------------------
L2GasPriceSuggesterFactor = 1

# ==============================================================================
# ____  ____   ____
# |  _ \|  _ \ / ___|
# | |_) | |_) | |
# |  _ <|  __/| |___
# |_| \_\_|    \____|
#
# ------------------------------------------------------------------------------
[RPC]

# ------------------------------------------------------------------------------
# Host is the IP address that the RPC's http server will bind to.
# ------------------------------------------------------------------------------
Host = "0.0.0.0"

# ------------------------------------------------------------------------------
# Port is used to configure which port our RPC http server will listen on
# ------------------------------------------------------------------------------
Port = {{.zkevm_rpc_http_port}}

# ------------------------------------------------------------------------------
# ReadTimeout determines the maximal amount of time that a client can
# spend sending us their request. After the configured amount of time
# the RPC will drop the connection.
# ------------------------------------------------------------------------------
ReadTimeout = "1m0s"

# ------------------------------------------------------------------------------
# WriteTimeout determines how long our server is willing to spend
# writing data to the response connection. If the client is very slow,
# we can time out here and reset the connection.
# ------------------------------------------------------------------------------
WriteTimeout = "1m0s"

# ------------------------------------------------------------------------------
# MaxRequestsPerIPAndSecond is used to configure how many requests a
# single IP address can make within a single second.  These values are
# tracked on each individual server (not centrally). So if you have a
# load balancer and several RPCs, it's possible that a user might be
# rate limited on just one of them
# ------------------------------------------------------------------------------
MaxRequestsPerIPAndSecond = 50

# ------------------------------------------------------------------------------
# SequencerNodeURI if configured will cause the RPC to relay certain
# requests to a different RPC. The relayed methods are:
# - eth_gasPriace
# - eth_coinbase
# - eth_syncing
# - eth_getTransactionByHash if we can't find it locally
# - eth_getTransactionCount
# - getting the pending tx count
# - sending a transaction
#
# By default the application will detect the trusted sequencer URL on
# it's own based on what ever is configured in the smart contract, but
# it's worth noting that there are some functions that read the
# configured value separately from the detected value.
# ------------------------------------------------------------------------------
SequencerNodeURI = ""

# ------------------------------------------------------------------------------
# MaxCumulativeGasUsed is used in the estimation of gas and counters
#
# Deprecated: This setting might not be needed given that we set it in
# the state.batch.constraints
# ------------------------------------------------------------------------------
MaxCumulativeGasUsed = 0

# ------------------------------------------------------------------------------
# EnableL2SuggestedGasPricePolling will enable the checking of min gas
# price. This must be enabled on order to support blocking
# transactions that have a gas price that's too low.
# ------------------------------------------------------------------------------
EnableL2SuggestedGasPricePolling = true

# ------------------------------------------------------------------------------
# BatchRequestsEnabled determines if the RPC should support an array
# of JSON RPC requests to be executed in a single batch request.
# ------------------------------------------------------------------------------
BatchRequestsEnabled = true

# ------------------------------------------------------------------------------
# BatchRequestsLimit will determine the max number of requests to be
# supported in a single batch request
# ------------------------------------------------------------------------------
BatchRequestsLimit = 50

# ------------------------------------------------------------------------------
# L2Coinbase is used to configure the response from the RPC for an
# eth_coinbase request. This will be used if the SequencerNodeURI is
# not configured. The L2Coinbase defined here is not important to the
# protocol
# ------------------------------------------------------------------------------
L2Coinbase = "0x0000000000000000000000000000000000000000"

# ------------------------------------------------------------------------------
# MaxLogsCount is a configuration to set the max number of logs that
# can be returned in a single call to the state, if zero it means no
# limit
# ------------------------------------------------------------------------------
MaxLogsCount = 1000

# ------------------------------------------------------------------------------
# MaxLogsBlockRange MaxLogsBlockRange is a configuration to set the
# max range for block number when querying TXslogs in a single call to
# the state, if zero it means no limit
# ------------------------------------------------------------------------------
MaxLogsBlockRange = 1000

# ------------------------------------------------------------------------------
# MaxNativeBlockHashBlockRange is a configuration to set the max range
# for block number when querying native block hashes in a single call
# to the state, if zero it means no limit
# ------------------------------------------------------------------------------
MaxNativeBlockHashBlockRange = 60000

# ------------------------------------------------------------------------------
# EnableHttpLog allows the user to enable or disable the logs related
# to the HTTP requests to be captured by the server.
# ------------------------------------------------------------------------------
EnableHttpLog = true

[RPC.WebSockets]

# ------------------------------------------------------------------------------
# Enabled determines if the RPC should serve websocket traffic
# ------------------------------------------------------------------------------
Enabled = true

# ------------------------------------------------------------------------------
# Host will determine which interface the web sock is bound to
# ------------------------------------------------------------------------------
Host = "0.0.0.0"

# ------------------------------------------------------------------------------
# Port specifies the port that websocket server will listen on
# ------------------------------------------------------------------------------
Port = {{.zkevm_rpc_ws_port}}

# ------------------------------------------------------------------------------
# ReadLimit will determine the max number of bytes for a message
# ------------------------------------------------------------------------------
ReadLimit = 104857600

# ------------------------------------------------------------------------------
# This section only applies to Estimation
# ------------------------------------------------------------------------------
[RPC.ZKCountersLimits]

# ------------------------------------------------------------------------------
# MaxKeccakHashes represents the maximum number of Keccak hash
# operations allowed across the Keccak state machines (Padding-KK,
# Padding-KK-Bit, Bits2Field, Keccak-F) before triggering an Out Of
# Counters (OOC) error
# ------------------------------------------------------------------------------
MaxKeccakHashes = 0

# ------------------------------------------------------------------------------
# MaxPoseidonHashes limits the total number of Poseidon hash
# computations that can be performed by the Poseidon SM during the
# processing of a batch, ensuring resource constraints are respected.
# ------------------------------------------------------------------------------
MaxPoseidonHashes = 0

# ------------------------------------------------------------------------------
# MaxPoseidonPaddings specifies the maximum number of padding
# operations the Poseidon SM can handle, typically used to align input
# sizes for hash computations.
# ------------------------------------------------------------------------------
MaxPoseidonPaddings = 0

# ------------------------------------------------------------------------------
# MaxMemAligns defines the upper limit of memory alignment operations
# that can be conducted by the Memory Align State Machine, critical
# for maintaining correct data structuring across state machines.
# ------------------------------------------------------------------------------
MaxMemAligns = 0

# ------------------------------------------------------------------------------
# MaxArithmetics sets the ceiling on the number of arithmetic
# operations (e.g., addition, multiplication, division) that the
# Arithmetic State Machine can execute, ensuring computational limits
# are adhered to.
# ------------------------------------------------------------------------------
MaxArithmetics = 0

# ------------------------------------------------------------------------------
# MaxBinaries saps the number of binary operations (like AND, OR, XOR)
# the Binary State Machine can perform, crucial for managing the
# execution resources within the zkProver framework.
# ------------------------------------------------------------------------------
MaxBinaries = 0

# ------------------------------------------------------------------------------
# MaxSteps total count of computational steps or operations the entire
# zkProver system can execute across all state machines for a single
# batch, integral to monitoring overall system load and preventing
# overuse.
# ------------------------------------------------------------------------------
MaxSteps = 0

# ------------------------------------------------------------------------------
# MaxSHA256Hashes establishes the limit on SHA256 hash operations
# performed within the system, ensuring compatibility with operations
# that might interact with external systems or need SHA256
# specifically for interoperability.
# ------------------------------------------------------------------------------
MaxSHA256Hashes = 0

# ==============================================================================
#  ______   ___   _  ____ _   _ ____   ___  _   _ ___ __________ ____
# / ___\ \ / / \ | |/ ___| | | |  _ \ / _ \| \ | |_ _|__  / ____|  _ \
# \___ \\ V /|  \| | |   | |_| | |_) | | | |  \| || |  / /|  _| | |_) |
#  ___) || | | |\  | |___|  _  |  _ <| |_| | |\  || | / /_| |___|  _ <
# |____/ |_| |_| \_|\____|_| |_|_| \_\\___/|_| \_|___/____|_____|_| \_\
#
# ------------------------------------------------------------------------------
[Synchronizer]

# ------------------------------------------------------------------------------
# SyncInterval defines the wait duration between reading new
# information from the trusted sequencer, DAC, L1. Specifically, this
# controls how long we wait between running sync operations and not
# the frequence of syncs.
# ------------------------------------------------------------------------------
SyncInterval = "1s"

# ------------------------------------------------------------------------------
# SyncChunkSize determines how large of a range of blocks we'll
# attempt to pull while getting the rollup information.
# ------------------------------------------------------------------------------
SyncChunkSize = 100

# ------------------------------------------------------------------------------
# TrustedSequencerURL is the RPC url to connect to in order to sync
# the trusted state. If this value is unset, we will read the trusted
# sequencer URL from the rollup smart contract.
# ------------------------------------------------------------------------------
TrustedSequencerURL = ""

# ------------------------------------------------------------------------------
# SyncBlockProtection determines which block tag is used for reading
# data from L1. Latest would read blocks of the tip of the chain which
# have a higher risk of being reorged. Safe and final are much less
# likely to be reorged:
#
# https://www.alchemy.com/overviews/ethereum-commitment-levels
#
# This value is configured for latest to speed up testing in the local
# environment but this is not recommened for production environments
# ------------------------------------------------------------------------------
# SyncBlockProtection = "safe"
# SyncBlockProtection = "finalized"
SyncBlockProtection = "latest"

# ------------------------------------------------------------------------------
# L1SyncCheckL2BlockHash will perform additional hash checks between a
# permissionless node and the trusted sequencer. This setting would
# add some additional querying and checking, but would help make it
# clear if for any reason the node drifts from the trusted state.
# ------------------------------------------------------------------------------
L1SyncCheckL2BlockHash = true

# ------------------------------------------------------------------------------
# L1SyncCheckL2BlockNumberhModulus sets a modulus in order to
# determine the frequency of blocks that should be checked assuming
# L1SyncCheckL2BlockHash is also enabled. E.g. if this value is set to
# 30, we'll trigger the checks every 30th L2 block.
# ------------------------------------------------------------------------------
L1SyncCheckL2BlockNumberhModulus = 30

# ------------------------------------------------------------------------------
# L1SynchronizationMode determines which mode of synchronization we
# should use. By default we use "sequential" synchronization in
# production environments. Parallel should be faster because it makes
# better utilization of the executor, but has been tested less.
# ------------------------------------------------------------------------------
L1SynchronizationMode = "sequential"

[Synchronizer.L1ParallelSynchronization]

# ------------------------------------------------------------------------------
# MaxClients determines how many workers we'll spawn in order to read
# L1 data and synchronize.
# ------------------------------------------------------------------------------
MaxClients = 10

# ------------------------------------------------------------------------------
# MaxPendingNoProcessedBlocks determines the size of the buffer used
# to store rollup information from L1. It must be greater than or
# equal to the MaxClients number. The suggested configuration is at 2x
# the number of MaxClients.
# ------------------------------------------------------------------------------
MaxPendingNoProcessedBlocks = 25

# ------------------------------------------------------------------------------
# RequestLastBlockPeriod determines how long we'll wait to request a
# new block from L1 assuming that we're already in sync.
# ------------------------------------------------------------------------------
RequestLastBlockPeriod = "5s"

# ------------------------------------------------------------------------------
# RequestLastBlockTimeout determines a maximum duration that we'll
# wait for a response when requesting a new block.
# ------------------------------------------------------------------------------
RequestLastBlockTimeout = "5s"

# ------------------------------------------------------------------------------
# RequestLastBlockMaxRetries can be used to define the max number of
# retries to request the L1 block
# ------------------------------------------------------------------------------
RequestLastBlockMaxRetries = 3

# ------------------------------------------------------------------------------
# StatisticsPeriod defines how often we should show a log with
# stats. Set this to 0 in order to disable all together.
# ------------------------------------------------------------------------------
StatisticsPeriod = "5m0s"

# ------------------------------------------------------------------------------
# TimeOutMainLoop determines how long we'll wait for the main
# synchronizer loop to complete
# ------------------------------------------------------------------------------
TimeOutMainLoop = "5m0s"

# ------------------------------------------------------------------------------
# RollupInfoRetriesSpacing determines the duration that we'll wait
# between successive retries to fetch L1 data.
# ------------------------------------------------------------------------------
RollupInfoRetriesSpacing = "5s"

# ------------------------------------------------------------------------------
# FallbackToSequentialModeOnSynchronized if true the synchronizer will
# use sequential mode once it is in sync.
# ------------------------------------------------------------------------------
FallbackToSequentialModeOnSynchronized = false

[Synchronizer.L1ParallelSynchronization.PerformanceWarning]

# ------------------------------------------------------------------------------
# AceptableInacctivityTime is the expected maximum time that the
# consumer could wait until new data is produced. If the time is
# greater it logs warning. The idea is to keep working the consumer as
# much as possible, so if the producer is not fast enough then you
# could increase the number of parallel clients to sync with L1
# ------------------------------------------------------------------------------
AceptableInacctivityTime = "5s"

# ------------------------------------------------------------------------------
# ApplyAfterNumRollupReceived configures a minimum number of processed
# events to see before processing further
# ------------------------------------------------------------------------------
ApplyAfterNumRollupReceived = 10

[Synchronizer.L2Synchronization]

# ------------------------------------------------------------------------------
# AcceptEmptyClosedBatches will enable or disable the acceptance of
# empty batches. If true, the synchronizer will accept empty batches
# and process them.
# ------------------------------------------------------------------------------
AcceptEmptyClosedBatches = false

# ------------------------------------------------------------------------------
# ReprocessFullBatchOnClose when a batch is closed, this setting will
# determine if we reprocess it or keep the trusted data.
# ------------------------------------------------------------------------------
ReprocessFullBatchOnClose = false

# ------------------------------------------------------------------------------
# CheckLastL2BlockHashOnCloseBatch if this is set to true, we'll check
# the last L2 block hash upon a batch being closed.
# ------------------------------------------------------------------------------
CheckLastL2BlockHashOnCloseBatch = true

# ==============================================================================
#  ____  _____ ___  _   _ _____ _   _  ____ _____ ____
# / ___|| ____/ _ \| | | | ____| \ | |/ ___| ____|  _ \
# \___ \|  _|| | | | | | |  _| |  \| | |   |  _| | |_) |
#  ___) | |__| |_| | |_| | |___| |\  | |___| |___|  _ <
# |____/|_____\__\_\\___/|_____|_| \_|\____|_____|_| \_\
#
# ------------------------------------------------------------------------------
[Sequencer]

# ------------------------------------------------------------------------------
# DeletePoolTxsL1BlockConfirmations is used to clear old and failed
# transactions based it has been since it's failed
# (14*DeletePoolTxsL1BlockConfirmations) or how many blocks have been
# mined since the batch was virtualized
# ------------------------------------------------------------------------------
DeletePoolTxsL1BlockConfirmations = 100

# ------------------------------------------------------------------------------
# DeletePoolTxsCheckInterval determines how often we'll attempt to
# clean up the pool. In a high throughput scenario, it might be worth
# while to lower this duration to avoid doing large deletes.
# ------------------------------------------------------------------------------
DeletePoolTxsCheckInterval = "12h0m0s"

# ------------------------------------------------------------------------------
# TxLifetimeCheckInterval determines how often we'll check the current
# txs in the pool to see if they have exceeded their lifetime
# ------------------------------------------------------------------------------
TxLifetimeCheckInterval = "10m0s"

# ------------------------------------------------------------------------------
# TxLifetimeMax determines how long a non-executable transaction can
# stay in the pool before being dropped.
# ------------------------------------------------------------------------------
TxLifetimeMax = "3h0m0s"

# ------------------------------------------------------------------------------
# LoadPoolTxsCheckInterval determines how frequently the sequencer
# will check to see if there are new transactions in the pool
# ------------------------------------------------------------------------------
LoadPoolTxsCheckInterval = "500ms"

# ------------------------------------------------------------------------------
# StateConsistencyCheckInterval determines how long the sequencer will
# wait to check if a state inconsistency has developed. This is
# essentially looking for trusted_reorgs of some kind that have
# occurred while the application has been running. If such an
# inconsistency develops, the finalizer will halt requiring a cleanup
# / restart.
# ------------------------------------------------------------------------------
StateConsistencyCheckInterval = "5s"

[Sequencer.Finalizer]

# ------------------------------------------------------------------------------
# ForcedBatchesTimeout is the time the finalizer waits after receiving
# the closing signal to process forced batches.
# ------------------------------------------------------------------------------
ForcedBatchesTimeout = "1m0s"

# ------------------------------------------------------------------------------
# NewTxsWaitInterval is the duration the finalizer will sleep between
# iterations if there are no pending transactions to be processed.
# ------------------------------------------------------------------------------
NewTxsWaitInterval = "100ms"

# ------------------------------------------------------------------------------
# ResourceExhaustedMarginPct is used to determine how much wiggle room
# we want to leave in a batch before closing due to running out of
# counters.
#
# E.g. our counter limit for PoseindonHashes is 252,357. This setting
# determines that we would close a batch if we have used
# ResourceExhaustedMarginPct out of 100. In the case of
# PoseidonHashes, if we have exceeded 25,235 in the current batch, we
# will close it.
# ------------------------------------------------------------------------------
ResourceExhaustedMarginPct = 10

# ------------------------------------------------------------------------------
# ForcedBatchesL1BlockConfirmations is used to determine finality for
# processing of forced batches.
# ------------------------------------------------------------------------------
ForcedBatchesL1BlockConfirmations = 64

# ------------------------------------------------------------------------------
# L1InfoTreeL1BlockConfirmations is used to determine finality for
# processing of deposits to the l1 info tree
# ------------------------------------------------------------------------------
L1InfoTreeL1BlockConfirmations = 64

# ------------------------------------------------------------------------------
# ForcedBatchesCheckInterval is the duration that the application will
# sleep between checks for forced batches on L1
# ------------------------------------------------------------------------------
ForcedBatchesCheckInterval = "30s"

# ------------------------------------------------------------------------------
# L1InfoTreeCheckInterval is the duration that the application will
# sleep between checks for updates to the L1 info tree
# ------------------------------------------------------------------------------
L1InfoTreeCheckInterval = "10s"

# ------------------------------------------------------------------------------
# BatchMaxDeltaTimestamp determines the max amount of time that a
# batch will be held open assuming it's not empty.
# ------------------------------------------------------------------------------
BatchMaxDeltaTimestamp = "5s"

# ------------------------------------------------------------------------------
# L2BlockMaxDeltaTimestamp is used to set the L2 block interval.
# ------------------------------------------------------------------------------
L2BlockMaxDeltaTimestamp = "3s"

# ------------------------------------------------------------------------------
# HaltOnBatchNumber is used to stop the sequencer once it hits a
# particular block number. The sequencer will stop processing
# transactions once this batch is closed. This is useful for cleanly
# stopping the sequencer for upgrades.
# ------------------------------------------------------------------------------
HaltOnBatchNumber = 0

# ------------------------------------------------------------------------------
# SequentialBatchSanityCheck configures the execution mode of the
# batch sanity check. When set to true, the batch sanity check is
# executed sequentially, meaning the sanity check operations are
# performed synchronously within the same goroutine that initiates
# them. This approach ensures that the batch is checked atomically and
# in order, respecting the execution sequence of operations as they
# are initiated. When set to false, the batch sanity check is executed
# in parallel using a separate goroutine. This allows the sanity check
# to run concurrently with other operations, potentially improving
# performance by not blocking the main execution flow while the sanity
# check is completed.
# ------------------------------------------------------------------------------
SequentialBatchSanityCheck = true

# ------------------------------------------------------------------------------
# SequentialProcessL2Block determines the threading context for the
# processing of L2 blocks. When set to true, L2 block processing
# occurs sequentially within the finalization routine. This means that
# the L2 block is processed synchronously in the same goroutine that
# handles final state transitions, ensuring immediate processing and
# integration of state changes. This setting is useful for scenarios
# where order and immediate consistency of block processing are
# critical. When set to false, L2 blocks are added to a queue for
# processing in a separate, asynchronous goroutine dedicated to
# handling pending L2 blocks. This asynchronous processing can enhance
# throughput by decoupling the processing workload from the final
# state transitions, at the cost of potential delays in state
# integration.
# ------------------------------------------------------------------------------
SequentialProcessL2Block = true

[Sequencer.Finalizer.Metrics]
# ------------------------------------------------------------------------------
# Interval determines the duration for L2 Blocks to be included for event
# ------------------------------------------------------------------------------
Interval = "1h0m0s"

# ------------------------------------------------------------------------------
# EnableLog will enable or disable the metrics logs
# ------------------------------------------------------------------------------
EnableLog = true

[Sequencer.StreamServer]

# ------------------------------------------------------------------------------
# Port will configure the port that the data streamer server will
# listen on
# ------------------------------------------------------------------------------
Port = {{.zkevm_data_streamer_port}}

# ------------------------------------------------------------------------------
# Filename is a location on disk that stores the stream file. This
# will need to be writable by the application
#
# https://github.com/0xPolygonHermez/zkevm-data-streamer?tab=readme-ov-file#stream-file
# ------------------------------------------------------------------------------
Filename = "/tmp/datastream.bin"

# ------------------------------------------------------------------------------
# Version determines the version of the stream file that will be
# written into the header. This could allow a client to check with the
# version number of a header to ensure they're reading from the
# correct source.
# ------------------------------------------------------------------------------
Version = 0

# ------------------------------------------------------------------------------
# ChainID is used to set the system id of the datastreamer. Like the
# version this also written to the header and can be used to determine
# if the correct stream is being read.
#
# Note: the value here is probably overwritten automatically by the
# value from on chain
#
# ------------------------------------------------------------------------------
ChainID = {{.zkevm_rollup_chain_id}}

# ------------------------------------------------------------------------------
# Enabled is used to turn the datastreamer on or off.
# ------------------------------------------------------------------------------
Enabled = true

# ------------------------------------------------------------------------------
# UpgradeEtrogBatchNumber is the batch number for the upgrade
# etrog. This is probably not needed for most use cases
# ------------------------------------------------------------------------------
UpgradeEtrogBatchNumber = 0

[Sequencer.StreamServer.Log]

# ------------------------------------------------------------------------------
# Environment generally dictates the format of the logs and the
# sampling rate. We often default to production even for development
# because of the JSON encoding.
#
# https://github.com/uber-go/zap/blob/a55bdc32f526699c3b4cc51a2cc97e944d02fbbf/config.go#L120
# https://github.com/uber-go/zap/blob/a55bdc32f526699c3b4cc51a2cc97e944d02fbbf/config.go#L161
# ------------------------------------------------------------------------------
Environment = "production"

# ------------------------------------------------------------------------------
# Level determines the log level that will be written to the
# log. Generally we'll switch to debug if we want to troubleshoot
# something specifically otherwise we leave it at info
# ------------------------------------------------------------------------------
Level = "info"

# ==============================================================================
#  ____  _____ ___  _   _ _____ _   _  ____ _____ ____  _____ _   _ ____  _____ ____
# / ___|| ____/ _ \| | | | ____| \ | |/ ___| ____/ ___|| ____| \ | |  _ \| ____|  _ \
# \___ \|  _|| | | | | | |  _| |  \| | |   |  _| \___ \|  _| |  \| | | | |  _| | |_) |
#  ___) | |__| |_| | |_| | |___| |\  | |___| |___ ___) | |___| |\  | |_| | |___|  _ <
# |____/|_____\__\_\\___/|_____|_| \_|\____|_____|____/|_____|_| \_|____/|_____|_| \_\
#
# ------------------------------------------------------------------------------
[SequenceSender]

# ------------------------------------------------------------------------------
# WaitPeriodSendSequence will determine how long we wait to check for
# new sequences to send assuming that we came up empty the last time
# we checked. E.g. if we query and find 0 sequences to send, we'll
# wait for WaitPeriodSendSequence before checking again
# ------------------------------------------------------------------------------
WaitPeriodSendSequence = "5s"

# ------------------------------------------------------------------------------
# LastBatchVirtualizationTimeMaxWaitPeriod defines the max amount of
# time that we'll allow to pass before virtualizing. E.g. if we have
# sequences to send and it's been more than
# LastBatchVirtualizationTimeMaxWaitPeriod since the last time we've
# virtualized, we'll send the sequences. Otherwise we'll wait longer.
# ------------------------------------------------------------------------------
LastBatchVirtualizationTimeMaxWaitPeriod = "5s"

# ------------------------------------------------------------------------------
# L1BlockTimestampMargin is the duration that must exist between the
# last L1 block and the last L2 block in the sequence before
# virtualizing. If the time of the last L1 block and the last L2 block
# is too close, we'll wait longer before attempting to sequence.
# ------------------------------------------------------------------------------
L1BlockTimestampMargin = "30s"

# ------------------------------------------------------------------------------
# MaxTxSizeForL1 is the maximum size a single transaction can
# have. This field has non-trivial consequences: larger transactions
# than 128KB are significantly harder and more expensive to propagate;
# larger transactions also take more resources to validate whether
# they fit into the pool or not.
# ------------------------------------------------------------------------------
MaxTxSizeForL1 = 131072

# ------------------------------------------------------------------------------
# ForkUpgradeBatchNumber is the batch number where a fork id change
# will occur. This can be used to disable sending new sequences after
# a certain point in time while still accepting new transactions into
# the pool
# ------------------------------------------------------------------------------
ForkUpgradeBatchNumber = 0

# ------------------------------------------------------------------------------
# GasOffset is an incremental last limit added to the estimation in
# order to avoid reverts due to state volatility.
# ------------------------------------------------------------------------------
GasOffset = 150000

# ------------------------------------------------------------------------------
# MaxBatchesForL1 is used to configure the maximum number of batches
# for a single sequence. If you want batches to be virtualized and
# verified faster, decreasing this number will help ensure that you're
# sequencing more often.
# ------------------------------------------------------------------------------
MaxBatchesForL1 = 10

# ------------------------------------------------------------------------------
# L2Coinbase should generally be the address of the trusted
# sequencer. The coinbase will receive fees on L2. This is also used
# to specify the coinbase in the batch and ultimately is used to
# determine the beneficiary of the proof verification. When we
# sequence batches on L1, we pay a batch fee. When the batches are
# eventually proven that collateral is refunded to the L2Coinbase.
# ------------------------------------------------------------------------------
L2Coinbase = "{{.zkevm_l2_sequencer_address}}"

# ------------------------------------------------------------------------------
# SenderAddress should generally be the address of the trusted
# sequencer. This is the address that that the manager uses for
# signing the L1 txs.
# ------------------------------------------------------------------------------
SenderAddress = "{{.zkevm_l2_sequencer_address}}"

# ------------------------------------------------------------------------------
# PrivateKey is a object with the keystore and password that are used
# for signing transactions. The keystore is a standard go-ethereum
# style keystore that is encrypted with the provided password. In this
# particular context, this needs to be the sequencers private key.
# ------------------------------------------------------------------------------
[SequenceSender.PrivateKey]
Path = "/etc/zkevm/sequencer.keystore"
Password = "{{.zkevm_l2_keystore_password}}"

# ==============================================================================
#     _    ____  ____ ____  _____ ____    _  _____ ___  ____
#    / \  / ___|/ ___|  _ \| ____/ ___|  / \|_   _/ _ \|  _ \
#   / _ \| |  _| |  _| |_) |  _|| |  _  / _ \ | || | | | |_) |
#  / ___ \ |_| | |_| |  _ <| |__| |_| |/ ___ \| || |_| |  _ <
# /_/   \_\____|\____|_| \_\_____\____/_/   \_\_| \___/|_| \_\
# ------------------------------------------------------------------------------
[Aggregator]
# ------------------------------------------------------------------------------
# Host is the IP address that the aggregator server will listen
# on. The provers are clients for the aggregator server.
# ------------------------------------------------------------------------------
Host = "0.0.0.0"

# ------------------------------------------------------------------------------
# Port is the port that the aggregator service will be listening on
# ------------------------------------------------------------------------------
Port = {{.zkevm_aggregator_port}}

# ------------------------------------------------------------------------------
# RetryTime is the amount of time that the main loop will wait between
# checking for proofs to aggregate or batches to prove.
# ------------------------------------------------------------------------------
RetryTime = "30s"

# ------------------------------------------------------------------------------
# VerifyProofInterval is the interval of time to verify and send
# proofs to L1
# ------------------------------------------------------------------------------
VerifyProofInterval = "5m0s"

# ------------------------------------------------------------------------------
# ProofStatePollingInterval will determine how long we wait between
# successive checks to see if a pending proof has been finished
# ------------------------------------------------------------------------------
ProofStatePollingInterval = "5s"

# ------------------------------------------------------------------------------
# TxProfitabilityCheckerType is used to specify an approach for
# determining if it's profitable for the aggregator to validate a
# batch.
#
# base: would check the amount of pending collateral and compare it to
# the TxProfitabilityMinReward. If the reward surpasses the minimum,
# we will verify the proof, otherwise we'll wait
#
# acceptall: will verify the even if there is very little reward
# ------------------------------------------------------------------------------
TxProfitabilityCheckerType = "acceptall"

# ------------------------------------------------------------------------------
# TxProfitabilityMinReward is used to configure the minimum reward
# if we're using the base model for tx profitability
# ------------------------------------------------------------------------------
TxProfitabilityMinReward = "1.1"

# ------------------------------------------------------------------------------
# IntervalAfterWhichBatchConsolidateAnyway is interval for the main
# sequencer, that will check if there is no transactions.
#
# Deprecated: can't tell if this particular setting is used. It's
# definitely in the code, but doesn't appear to be read
#
# ------------------------------------------------------------------------------
IntervalAfterWhichBatchConsolidateAnyway = "0s"

# ------------------------------------------------------------------------------
# ChainID is the L2 ChainID and this is used as input to the prover
#
# Note: the value here is probably overwritten automatically by the
# value from on chain
#
# ------------------------------------------------------------------------------
ChainID = {{.zkevm_rollup_chain_id}}

# ------------------------------------------------------------------------------
# ForkId is the fork id that we're currently using
#
# Note: this value is likely overwritten from the values from onchain
#
# Deprecated: it seems like this particular field might not be used
#
# ------------------------------------------------------------------------------
ForkId = 0

# ------------------------------------------------------------------------------
# CleanupLockedProofsInterval determines the wait duration between
# successive calls to clean up locked proofs.
# ------------------------------------------------------------------------------
CleanupLockedProofsInterval = "2m0s"

# ------------------------------------------------------------------------------
# GeneratingProofCleanupThreshold determines the max amount of time
# that we'd be willing to wait for a proof to be generated. Every
# CleanupLockedProofsInterval we will check for proofs that have been
# generating for longer than GeneratingProofCleanupThreshold. Those
# proofs will be deleted and retried.
# ------------------------------------------------------------------------------
GeneratingProofCleanupThreshold = "10m"

# ------------------------------------------------------------------------------
# GasOffset is an incremental last limit added to the estimation in
# order to avoid reverts due to state volatility. This would only
# matter if we are settling directly with L1 rather than using the
# AggLayer
# ------------------------------------------------------------------------------
GasOffset = 150000

# ------------------------------------------------------------------------------
# UpgradeEtrogBatchNumber is the batch number that we'll use to
# trigger the etrog upgrade.
# ------------------------------------------------------------------------------
UpgradeEtrogBatchNumber = 0

{{if .is_cdk_validium}}
## CDK Validium Specific Settings

# ------------------------------------------------------------------------------
# SenderAddress is used as input for the prover. The address that's
# configured here must match the ultimate sender of the aggregated
# proof to L1. In this case the final sender is the agglayer itself
# ------------------------------------------------------------------------------
SenderAddress = "{{.zkevm_l2_agglayer_address}}"

# ------------------------------------------------------------------------------
# SettlementBackend determines if we're settling with the `agglayer'
# or `direct' with L1
# ------------------------------------------------------------------------------
SettlementBackend = "agglayer"

# ------------------------------------------------------------------------------
# AggLayerTxTimeout determines how long we'll wait for the AggLayer to
# respond successfully that a transaction has been mined on L1. The
# current implementation will block while we wait, so it makes sense
# not to push this number overly high.
# ------------------------------------------------------------------------------
AggLayerTxTimeout = "600s"

# ------------------------------------------------------------------------------
# AggLayerURL is the RPC URL of the agglayer itself
# ------------------------------------------------------------------------------
AggLayerURL = "http://zkevm-agglayer{{.deployment_suffix}}:{{.zkevm_agglayer_port}}"
{{else}}

# ------------------------------------------------------------------------------
# SenderAddress represents the address of the trusted aggregator
# ------------------------------------------------------------------------------
SenderAddress = "{{.zkevm_l2_aggregator_address}}"
{{end}}

# ------------------------------------------------------------------------------
# PrivateKey is a object with the keystore and password that are used
# for signing transactions. The keystore is a standard go-ethereum
# style keystore that is encrypted with the provided password. In this
# particular context, this needs to be the sequencers private key.
# ------------------------------------------------------------------------------
[Aggregator.SequencerPrivateKey]
Path = "/etc/zkevm/sequencer.keystore"
Password = "{{.zkevm_l2_keystore_password}}"
# Path = "/etc/zkevm/proofsigner.keystore"
# Password = "{{.zkevm_l2_keystore_password}}"

# ==============================================================================
#   _     ____   ____    _    ____  ____  ____  ___ ____ _____
#  | |   |___ \ / ___|  / \  / ___||  _ \|  _ \|_ _/ ___| ____|
#  | |     __) | |  _  / _ \ \___ \| |_) | |_) || | |   |  _|
#  | |___ / __/| |_| |/ ___ \ ___) |  __/|  _ < | | |___| |___
#  |_____|_____|\____/_/   \_\____/|_|   |_| \_\___\____|_____|
#  ____  _   _  ____  ____ _____ ____ _____ _____ ____
# / ___|| | | |/ ___|/ ___| ____/ ___|_   _| ____|  _ \
# \___ \| | | | |  _| |  _|  _| \___ \ | | |  _| | |_) |
#  ___) | |_| | |_| | |_| | |___ ___) || | | |___|  _ <
# |____/ \___/ \____|\____|_____|____/ |_| |_____|_| \_\
#
# ------------------------------------------------------------------------------
[L2GasPriceSuggester]

# ------------------------------------------------------------------------------
# Type is used to select which type of gas price suggestion we'll use
#
# default: the default model will use the Factor as a percentage of
# the default gas price
#
# lastnbatches: will check the last CheckBlocks number of blocks to
# determine the gas price based on the configured Percentile
#
# follower: will track the current L1 gas price and use the Factor
# scale from the L1 price
#
# ------------------------------------------------------------------------------
Type = "follower"

# ------------------------------------------------------------------------------
# DefaultGasPriceWei can be used to set the gas price in the `default'
# mode or as the min gas price when using `follower` mode
# ------------------------------------------------------------------------------
DefaultGasPriceWei = 2000000000

# ------------------------------------------------------------------------------
# MaxGasPriceWei sets a cap on L2 gas price
# ------------------------------------------------------------------------------
MaxGasPriceWei = 0

# ------------------------------------------------------------------------------
# CheckBlocks used to configure how many previous blocks will be
# checked while in `lastnbatches` mode
# ------------------------------------------------------------------------------
CheckBlocks = 0

# ------------------------------------------------------------------------------
# Percentile determines the percentile to be used in `lastnbatches'
# mode. The logic is that we would fetch CheckBlocks blocks and then
# sort the prices and pull the price based on the configured
# Percentile
# ------------------------------------------------------------------------------
Percentile = 0

# ------------------------------------------------------------------------------
# UpdatePeriod determins how often we'll call the UpdateGasPriceAvg
# method of our gas pricer
# ------------------------------------------------------------------------------
UpdatePeriod = "10s"

# ------------------------------------------------------------------------------
# CleanHistoryPeriod determines how often we'll clean up the gas price
# history data in our pool db
# ------------------------------------------------------------------------------
CleanHistoryPeriod = "1h0m0s"

# ------------------------------------------------------------------------------
# CleanHistoryTimeRetention determines the retention period for which
# we'll keep gas prices.
# ------------------------------------------------------------------------------
CleanHistoryTimeRetention = "5m0s"

# ------------------------------------------------------------------------------
# Factor is used in the follower and default modes to scale up or down
# the gas prices.
# ------------------------------------------------------------------------------
Factor = 0.15

# ==============================================================================
#  _______  _______ ____ _   _ _____ ___  ____
# | ____\ \/ / ____/ ___| | | |_   _/ _ \|  _ \
# |  _|  \  /|  _|| |   | | | | | || | | | |_) |
# | |___ /  \| |__| |___| |_| | | || |_| |  _ <
# |_____/_/\_\_____\____|\___/  |_| \___/|_| \_\
#
# ------------------------------------------------------------------------------
[Executor]

# ------------------------------------------------------------------------------
# URI indicates the hostname/ip and port of the executor
# ------------------------------------------------------------------------------
URI = "zkevm-prover{{.deployment_suffix}}:{{.zkevm_executor_port}}"

# ------------------------------------------------------------------------------
# MaxResourceExhaustedAttempts is the max number of attempts to make a
# transaction succeed because of resource exhaustion
# ------------------------------------------------------------------------------
MaxResourceExhaustedAttempts = 3

# ------------------------------------------------------------------------------
# WaitOnResourceExhaustion is the duration to wait before retrying a
# transaction that failed due to resource exhaustion
# ------------------------------------------------------------------------------
WaitOnResourceExhaustion = "1s"

# ------------------------------------------------------------------------------
# MaxGRPCMessageSize sets the maximum message size in bytes the client
# can receive. If this is not set, gRPC uses the default 4MB.
# ------------------------------------------------------------------------------
MaxGRPCMessageSize = 100000000

# ==============================================================================
#  __  __ _____ ____ _     ___ _____ _   _ _____
# |  \/  |_   _/ ___| |   |_ _| ____| \ | |_   _|
# | |\/| | | || |   | |    | ||  _| |  \| | | |
# | |  | | | || |___| |___ | || |___| |\  | | |
# |_|  |_| |_| \____|_____|___|_____|_| \_| |_|
#
# ------------------------------------------------------------------------------
[MTClient]

# ------------------------------------------------------------------------------
# URI indicates the hostname/ip and port of the hash db service of the
# executor / prover
# ------------------------------------------------------------------------------
URI  = "zkevm-prover{{.deployment_suffix}}:{{.zkevm_hash_db_port}}"

# ==============================================================================
#  __  __ _____ _____ ____  ___ ____ ____
# |  \/  | ____|_   _|  _ \|_ _/ ___/ ___|
# | |\/| |  _|   | | | |_) || | |   \___ \
# | |  | | |___  | | |  _ < | | |___ ___) |
# |_|  |_|_____| |_| |_| \_\___\____|____/
# ------------------------------------------------------------------------------
[Metrics]

# ------------------------------------------------------------------------------
# Host is the ip that the prometheus service will listen on
# ------------------------------------------------------------------------------
Host = "0.0.0.0"

# ------------------------------------------------------------------------------
# Port is the port that will be used for listening metrics requests.
# ------------------------------------------------------------------------------
Port = {{.zkevm_prometheus_port}}

# ------------------------------------------------------------------------------
# Enabled determines if the metrics will be exposed or not
# ------------------------------------------------------------------------------
Enabled = true

# ------------------------------------------------------------------------------
# ProfilingHost is the ip that the go debug service will listen on
# ------------------------------------------------------------------------------
ProfilingHost = "0.0.0.0"

# ------------------------------------------------------------------------------
# ProfilingPort is the port that the go debug and pprof service will
# listen on
# ------------------------------------------------------------------------------
ProfilingPort = {{.zkevm_pprof_port}}

# ------------------------------------------------------------------------------
# ProfilingEnabled determines if profiling is enabled
# ------------------------------------------------------------------------------
ProfilingEnabled = true

# ==============================================================================
#  _______     _______ _   _ _____ _     ___   ____
# | ____\ \   / / ____| \ | |_   _| |   / _ \ / ___|
# |  _|  \ \ / /|  _| |  \| | | | | |  | | | | |  _
# | |___  \ V / | |___| |\  | | | | |__| |_| | |_| |
# |_____|  \_/  |_____|_| \_| |_| |_____\___/ \____|
# ------------------------------------------------------------------------------
[EventLog.DB]
# ------------------------------------------------------------------------------
# User specifies the username for database connection authentication.
# ------------------------------------------------------------------------------
User = "{{.event_db.user}}"

# ------------------------------------------------------------------------------
# Password is the authentication credential for the database connection.
# ------------------------------------------------------------------------------
Password = "{{.event_db.password}}"

# ------------------------------------------------------------------------------
# Name is the identifier of the target database to connect to.
# ------------------------------------------------------------------------------
Name = "{{.event_db.name}}"

# ------------------------------------------------------------------------------
# Host is the network address (hostname or IP) used to establish a database
# connection. Append deployment-specific suffixes as needed.
# ------------------------------------------------------------------------------
Host = "{{.event_db.hostname}}"

# ------------------------------------------------------------------------------
# Port defines the network port used for the database connection.
# ------------------------------------------------------------------------------
Port = "{{.event_db.port}}"

# ------------------------------------------------------------------------------
# EnableLog toggles the logging of all executed queries. Enabling this
# feature will significantly increase log volume and may affect performance.
# ------------------------------------------------------------------------------
EnableLog = true

# ------------------------------------------------------------------------------
# MaxConns sets the maximum number of concurrent connections in the pool.
# Adjust this value based on the database's configuration limits and expected
# client load to optimize performance and resource utilization.
# ------------------------------------------------------------------------------
MaxConns = 20

# ==============================================================================
#  _   _    _    ____  _   _ ____  ____
# | | | |  / \  / ___|| | | |  _ \| __ )
# | |_| | / _ \ \___ \| |_| | | | |  _ \
# |  _  |/ ___ \ ___) |  _  | |_| | |_) |
# |_| |_/_/   \_\____/|_| |_|____/|____/
#
# ------------------------------------------------------------------------------
[HashDB]
# ------------------------------------------------------------------------------
# User specifies the username for database connection authentication.
# ------------------------------------------------------------------------------
User = "{{.prover_db.user}}"

# ------------------------------------------------------------------------------
# Password is the authentication credential for the database connection.
# ------------------------------------------------------------------------------
Password = "{{.prover_db.password}}"

# ------------------------------------------------------------------------------
# Name is the identifier of the target database to connect to.
# ------------------------------------------------------------------------------
Name = "{{.prover_db.name}}"

# ------------------------------------------------------------------------------
# Host is the network address (hostname or IP) used to establish a database
# connection. Append deployment-specific suffixes as needed.
# ------------------------------------------------------------------------------
Host = "{{.prover_db.hostname}}"

# ------------------------------------------------------------------------------
# Port defines the network port used for the database connection.
# ------------------------------------------------------------------------------
Port = "{{.prover_db.port}}"

# ------------------------------------------------------------------------------
# EnableLog toggles the logging of all executed queries. Enabling this
# feature will significantly increase log volume and may affect performance.
# ------------------------------------------------------------------------------
EnableLog = false

# ------------------------------------------------------------------------------
# MaxConns sets the maximum number of concurrent connections in the pool.
# Adjust this value based on the database's configuration limits and expected
# client load to optimize performance and resource utilization.
# ------------------------------------------------------------------------------
MaxConns = 20

# ==============================================================================
#  ____ _____  _  _____ _____
# / ___|_   _|/ \|_   _| ____|
# \___ \ | | / _ \ | | |  _|
#  ___) || |/ ___ \| | | |___
# |____/ |_/_/   \_\_| |_____|
#
# The settings in the top level State object aren't really
# configurable. There just here for illustration purposes. These
# settings should look familiar and in most cases these are hard coded
# by the application itself or they're configured in other parts of
# this file
#
# ------------------------------------------------------------------------------
[State]
MaxCumulativeGasUsed = 0
ChainID = 0
MaxResourceExhaustedAttempts = 0
WaitOnResourceExhaustion = "0s"
ForkUpgradeBatchNumber = 0
ForkUpgradeNewForkId = 0
MaxLogsCount = 0
MaxLogsBlockRange = 0
MaxNativeBlockHashBlockRange = 0
AvoidForkIDInMemory = false

[State.DB]

# ------------------------------------------------------------------------------
# User specifies the username for database connection authentication.
# ------------------------------------------------------------------------------
User = "{{.state_db.user}}"

# ------------------------------------------------------------------------------
# Password is the authentication credential for the database connection.
# ------------------------------------------------------------------------------
Password = "{{.state_db.password}}"

# ------------------------------------------------------------------------------
# Name is the identifier of the target database to connect to.
# ------------------------------------------------------------------------------
Name = "{{.state_db.name}}"

# ------------------------------------------------------------------------------
# Host is the network address (hostname or IP) used to establish a database
# connection. Append deployment-specific suffixes as needed.
# ------------------------------------------------------------------------------
Host = "{{.state_db.hostname}}"

# ------------------------------------------------------------------------------
# Port defines the network port used for the database connection.
# ------------------------------------------------------------------------------
Port = "{{.state_db.port}}"

# ------------------------------------------------------------------------------
# EnableLog toggles the logging of all executed queries. Enabling this
# feature will significantly increase log volume and may affect performance.
# ------------------------------------------------------------------------------
EnableLog = false

# ------------------------------------------------------------------------------
# MaxConns sets the maximum number of concurrent connections in the pool.
# Adjust this value based on the database's configuration limits and expected
# client load to optimize performance and resource utilization.
# ------------------------------------------------------------------------------
MaxConns = 20

# https://github.com/0xPolygonHermez/zkevm-rom/blob/main/docs/opcode-cost-zk-counters.md
# https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/knowledge-layer/architecture/PDFs/aggregator.pdf
# https://github.com/0xPolygonHermez/zkevm-proverjs/tree/main/src/sm
# https://docs.polygon.technology/zkEVM/architecture/zkprover/
[State.Batch.Constraints]

# ------------------------------------------------------------------------------
# MaxTxsPerBatch determines a maximum highest number of transactions
# to be placed in a single batch.
# ------------------------------------------------------------------------------
MaxTxsPerBatch = 300

# ------------------------------------------------------------------------------
# MaxBatchBytesSize configures the maximum total size of the l2 blocks
# to be placed within a single batch
# ------------------------------------------------------------------------------
MaxBatchBytesSize = 120000

# ------------------------------------------------------------------------------
# MaxCumulativeGasUsed sets a very high limit on the total amount of
# gas that can be used
# ------------------------------------------------------------------------------
MaxCumulativeGasUsed = 1125899906842624

# ------------------------------------------------------------------------------
# MaxKeccakHashes represents the maximum number of Keccak hash
# operations allowed across the Keccak state machines (Padding-KK,
# Padding-KK-Bit, Bits2Field, Keccak-F) before triggering an Out Of
# Counters (OOC) error
# ------------------------------------------------------------------------------
MaxKeccakHashes = 2145

# ------------------------------------------------------------------------------
# MaxPoseidonHashes limits the total number of Poseidon hash
# computations that can be performed by the Poseidon SM during the
# processing of a batch, ensuring resource constraints are respected.
# ------------------------------------------------------------------------------
MaxPoseidonHashes = 252357

# ------------------------------------------------------------------------------
# MaxPoseidonPaddings specifies the maximum number of padding
# operations the Poseidon SM can handle, typically used to align input
# sizes for hash computations.
# ------------------------------------------------------------------------------
MaxPoseidonPaddings = 135191

# ------------------------------------------------------------------------------
# MaxMemAligns defines the upper limit of memory alignment operations
# that can be conducted by the Memory Align State Machine, critical
# for maintaining correct data structuring across state machines.
# ------------------------------------------------------------------------------
MaxMemAligns = 236585

# ------------------------------------------------------------------------------
# MaxArithmetics sets the ceiling on the number of arithmetic
# operations (e.g., addition, multiplication, division) that the
# Arithmetic State Machine can execute, ensuring computational limits
# are adhered to.
# ------------------------------------------------------------------------------
MaxArithmetics = 236585

# ------------------------------------------------------------------------------
# MaxBinaries saps the number of binary operations (like AND, OR, XOR)
# the Binary State Machine can perform, crucial for managing the
# execution resources within the zkProver framework.
# ------------------------------------------------------------------------------
MaxBinaries = 473170

# ------------------------------------------------------------------------------
# MaxSteps total count of computational steps or operations the entire
# zkProver system can execute across all state machines for a single
# batch, integral to monitoring overall system load and preventing
# overuse.
# ------------------------------------------------------------------------------
MaxSteps = 7570538

# ------------------------------------------------------------------------------
# MaxSHA256Hashes establishes the limit on SHA256 hash operations
# performed within the system, ensuring compatibility with operations
# that might interact with external systems or need SHA256
# specifically for interoperability.
# ------------------------------------------------------------------------------
MaxSHA256Hashes = 1596
